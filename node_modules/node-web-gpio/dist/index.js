"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestGPIOAccess = exports.OperationError = exports.InvalidAccessError = exports.GPIOPort = exports.GPIOPortMap = exports.GPIOAccess = void 0;
const events_1 = require("events");
const fs_1 = require("fs");
const path = require("path");
/**
 * Interval of file system polling, in milliseconds.
 */
const PollingInterval = 100;
/**
 * GPIO パス
 */
const SysfsGPIOPath = '/sys/class/gpio';
/**
 * GPIO ポートマップサイズ
 */
const GPIOPortMapSizeMax = 1024;
/**
 * Uint16 Max サイズ
 */
const Uint16Max = 65535;
/**
 *
 * Uint16型変換処理
 * @param parseString 変換文字列
 * @return Uint16型変換値
 */
function parseUint16(parseString) {
    const n = Number.parseInt(parseString, 10);
    if (0 <= n && n <= Uint16Max)
        return n;
    else
        throw new RangeError(`Must be between 0 and ${Uint16Max}.`);
}
/**
 * GPIO
 */
class GPIOAccess extends events_1.EventEmitter {
    /** ポート */
    _ports;
    /** GPIO チェンジイベントハンドラ */
    onchange;
    /**
     * Creates an instance of GPIOAccess.
     * @param ports ポート番号
     */
    constructor(ports) {
        super();
        this._ports = ports == null ? new GPIOPortMap() : ports;
        this._ports.forEach((port) => port.on('change', (event) => {
            this.emit('change', event);
        }));
        this.on('change', (event) => {
            if (this.onchange !== undefined)
                this.onchange(event);
        });
    }
    /**
     * ポート情報取得処理
     * @return 現在のポート情報
     */
    get ports() {
        return this._ports;
    }
    /**
     * Unexport all exported GPIO ports.
     * 全てのポート開放をする
     * @return ポート開放結果
     */
    async unexportAll() {
        await Promise.all([...this.ports.values()].map((port) => port.exported ? port.unexport() : undefined));
    }
}
exports.GPIOAccess = GPIOAccess;
/**
 * Different from Web GPIO API specification.
 */
class GPIOPortMap extends Map {
}
exports.GPIOPortMap = GPIOPortMap;
/**
 * GPIO ポート
 */
class GPIOPort extends events_1.EventEmitter {
    /** ポート番号 */
    _portNumber;
    /** ポーリング間隔 */
    _pollingInterval;
    /** 入出力方向 */
    _direction;
    /** エクスポート */
    _exported;
    /** エクスポートリトライ回数 */
    _exportRetry;
    /** 入出力値 */
    _value;
    /** タイムアウト値 */
    _timeout;
    /** GPIO チェンジイベントハンドラ */
    onchange;
    /**
     * Creates an instance of GPIOPort.
     * @param portNumber ポート番号
     */
    constructor(portNumber) {
        super();
        this._portNumber = parseUint16(portNumber.toString());
        this._pollingInterval = PollingInterval;
        this._direction = new OperationError('Unknown direction.');
        this._exported = new OperationError('Unknown export.');
        this._exportRetry = 0;
        this.on('change', (event) => {
            if (this.onchange !== undefined)
                this.onchange(event);
        });
    }
    /**
     * ポート番号取得処理
     * @return 現在のポート番号
     */
    get portNumber() {
        return this._portNumber;
    }
    /**
     * ポート名取得処理
     * @return 現在のポート名
     */
    get portName() {
        return `gpio${this.portNumber}`;
    }
    /**
     * ピン名取得処理
     * @return 現在のピン名
     */
    get pinName() {
        // NOTE: Unknown pinName.
        return '';
    }
    /**
     * GPIO 入出力方向 getter
     * @return 現在のGPIO 入出力方向
     */
    get direction() {
        if (this._direction instanceof OperationError)
            throw this._direction;
        return this._direction;
    }
    /**
     * GPIO export の有無 getter
     * @return 現在のGPIO 出力
     */
    get exported() {
        if (this._exported instanceof OperationError)
            throw this._exported;
        return this._exported;
    }
    /**
     * GPIO 出力処理
     * @param direction GPIO 入出力方向
     * @return export 処理の完了
     */
    async export(direction) {
        if (!/^(in|out)$/.test(direction)) {
            throw new InvalidAccessError(`Must be "in" or "out".`);
        }
        try {
            await fs_1.promises.access(path.join(SysfsGPIOPath, this.portName));
            this._exported = true;
        }
        catch {
            this._exported = false;
        }
        try {
            clearInterval(this._timeout);
            if (!this.exported) {
                await fs_1.promises.writeFile(path.join(SysfsGPIOPath, 'export'), String(this.portNumber));
            }
            await fs_1.promises.writeFile(path.join(SysfsGPIOPath, this.portName, 'direction'), direction);
            if (direction === 'in') {
                this._timeout = setInterval(
                // eslint-disable-next-line
                this.read.bind(this), this._pollingInterval);
            }
        }
        catch (error) {
            if (this._exportRetry == 0) {
                await sleep(100);
                console.warn('May be the first time port access. Retry..');
                ++this._exportRetry;
                await this.export(direction);
            }
            else {
                throw new OperationError(error);
            }
        }
        this._direction = direction;
        this._exported = true;
    }
    /**
     * Unexport exported GPIO ports.
     * ポート開放をする
     * @return ポート開放処理の完了
     */
    async unexport() {
        clearInterval(this._timeout);
        try {
            await fs_1.promises.writeFile(path.join(SysfsGPIOPath, 'unexport'), String(this.portNumber));
        }
        catch (error) {
            throw new OperationError(error);
        }
        this._exported = false;
    }
    /**
     * 入力値読み取り処理
     * @return 読み取り処理の完了
     */
    async read() {
        if (!(this.exported && this.direction === 'in')) {
            throw new InvalidAccessError(`The exported must be true and value of direction must be "in".`);
        }
        try {
            const buffer = await fs_1.promises.readFile(path.join(SysfsGPIOPath, this.portName, 'value'));
            const value = parseUint16(buffer.toString());
            if (this._value !== value) {
                this._value = value;
                this.emit('change', { value, port: this });
            }
            return value;
        }
        catch (error) {
            throw new OperationError(error);
        }
    }
    /**
     * 出力値書き込み処理
     * @return 読み取り処理の完了
     */
    async write(value) {
        if (!(this.exported && this.direction === 'out')) {
            throw new InvalidAccessError(`The exported must be true and value of direction must be "out".`);
        }
        try {
            await fs_1.promises.writeFile(path.join(SysfsGPIOPath, this.portName, 'value'), parseUint16(value.toString()).toString());
        }
        catch (error) {
            throw new OperationError(error);
        }
    }
}
exports.GPIOPort = GPIOPort;
/**
 * 無効なアクセスエラー
 */
class InvalidAccessError extends Error {
    /**
     * Creates an instance of InvalidAccessError.
     * @param message エラーメッセージ
     */
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
    }
}
exports.InvalidAccessError = InvalidAccessError;
/**
 * 操作エラー
 */
class OperationError extends Error {
    /**
     * Creates an instance of OperationError.
     * @param message エラーメッセージ
     */
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
    }
}
exports.OperationError = OperationError;
// Web GPIOの仕様に基づく意図的なasync関数の使用なので、ルールを無効化
// eslint-disable-next-line
async function requestGPIOAccess() {
    const ports = new GPIOPortMap([...Array(GPIOPortMapSizeMax).keys()].map((portNumber) => [
        portNumber,
        new GPIOPort(portNumber),
    ]));
    return new GPIOAccess(ports);
}
exports.requestGPIOAccess = requestGPIOAccess;
/**
 * 待機 関数
 * @param ms スリープ時間（ミリ秒）
 * @return 待機完了
 */
function sleep(ms) {
    return new Promise((resolve) => {
        return setTimeout(resolve, ms);
    });
}
